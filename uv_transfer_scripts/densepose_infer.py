# -*- coding: utf-8 -*-
"""pose-estimation-for-magic-animate.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1KjPpZun9EtlEMcFDEo93kFPqbL4ZmEOq
"""

import sys
import os
import cv2
import torch
import pandas as pd
from detectron2.engine.defaults import DefaultPredictor
from apply_net import create_argument_parser, DumpAction
from densepose.vis.extractor import DensePoseResultExtractor
from densepose.structures import DensePoseDataRelative
from densepose.vis.base import MatrixVisualizer
import numpy as np

# Function to install detectron2 if not already installed
def install_detectron2():
    if not os.path.exists('detectron2'):
        os.system('git clone --recursive https://github.com/facebookresearch/detectron2')
        os.system('python -m pip install git+https://github.com/facebookresearch/detectron2.git')

#install_detectron2()

# Set up argument parser and configuration
parser = create_argument_parser()
args = parser.parse_args(args=[
    "dump",
    "configs/densepose_rcnn_R_50_FPN_s1x.yaml",
    "model_final_0ed407.pkl",
    "input.jpg",
    "--output",
    "dump.pkl"
])

opts = []
cfg = DumpAction.setup_config(args.cfg, args.model, args, opts)

# Initialize the predictor
predictor = DefaultPredictor(cfg)
context = DumpAction.create_context(args, cfg)

# Load the input image
image_path = "/mnt/c/Users/Downloads/output_frame_0021.png"
img = cv2.imread(image_path)

# Function to perform prediction
def predict(img, predictor):
    with torch.no_grad():
        outputs = predictor(img)["instances"]
        outputs = outputs.to("cpu")
    return outputs

# Perform prediction
outputs = predict(img, predictor)

# Extract DensePose results
extractor = DensePoseResultExtractor()
data = extractor(outputs)
densepose_result, boxes_xywh = data

# Set up the visualizer
val_scale = 255.0 / DensePoseDataRelative.N_PART_LABELS
mask_visualizer = MatrixVisualizer(
    inplace=True, cmap=cv2.COLORMAP_VIRIDIS, val_scale=val_scale, alpha=1.0
)

# Prepare the visualization matrix
img_height, img_width = img.shape[:2]
matrix_scaled_8u = np.zeros((img_height, img_width), dtype=np.uint8)
matrix_vis = cv2.applyColorMap(matrix_scaled_8u, cv2.COLORMAP_VIRIDIS)

# Visualize the first person's pose and extract UV coordinates
uv_coordinates = []

if len(densepose_result) > 0:
    result = densepose_result[0]
    iuv_array = torch.cat(
        (result.labels[None].type(torch.float32), result.uv * 255.0)
    ).cpu().type(torch.uint8).cpu().numpy()

    bbox_xywh = boxes_xywh.cpu().numpy()[0]

    def _extract_uv_from_iuvarr(iuv_arr):
        i = iuv_arr[0, :, :]
        u = iuv_arr[1, :, :]
        v = iuv_arr[2, :, :]
        return i, u, v

    i, u, v = _extract_uv_from_iuvarr(iuv_array)
    uv_coordinates.append((i, u, v))

    matrix = i
    segm = i
    mask = np.zeros(matrix.shape, dtype=np.uint8)
    mask[segm >= 0] = 1

    mask_visualizer.visualize(matrix_vis, mask, matrix, bbox_xywh)

    # Adjust the output image size
    height, width = matrix_vis.shape[:2]
    if height > width:
        pad = (height - width) // 2
        matrix_vis = np.pad(matrix_vis, ((0, 0), (pad, pad), (0, 0)), 'edge')
    elif width > height:
        pad = (width - height) // 2
        matrix_vis = np.pad(matrix_vis, ((pad, pad), (0, 0), (0, 0)), 'edge')

    matrix_vis = cv2.resize(matrix_vis, (img_width, img_height), cv2.INTER_NEAREST)

    # Save the output image
    output_image_path = "output.png"
    cv2.imwrite(output_image_path, matrix_vis)

    print(f"Output image saved to {output_image_path}")
    print("UV coordinates extracted successfully.")

else:
    print("No DensePose results found in the input image.")

# Save the UV coordinates to a CSV file
if uv_coordinates:
    uv_data = []
    for i, u, v in uv_coordinates:
        for row in range(i.shape[0]):
            for col in range(i.shape[1]):
                uv_data.append([i[row, col], u[row, col], v[row, col]])

    uv_df = pd.DataFrame(uv_data, columns=["PartIndex", "U", "V"])
    uv_df.to_csv("uv_coordinates.csv", index=False)

    print("UV coordinates saved to uv_coordinates.csv")
